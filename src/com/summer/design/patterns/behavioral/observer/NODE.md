## 观察者模式
定义：
- 定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新
- 又叫 发布—订阅模式（Publisher&&Subscriber）

使用场景：
- 一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知

这里的demo用的是《head first设计模式》上的例子，并且进行了再次简化，
只保留了能说明该模式意图和结构的部分，实现方式是基于jdk提供的observer相关类，
实际场景中不是必须的，也可以手动实现，原理是一样的。

### 组成结构
- WeatherDate    实际变化的对象
- WeatherEquipment    被观察对象，继承Observable类
- WeatherBulletinBoard    观察者，实现Observer接口，重写update方法

### 说明
气象设备采集气象信息，当设备上的数值变化时，气象公告板也随着一起更新。
其中观察者是气象公告板，观察的是气象设备，但是实际变化的是气象信息。

在客户端调用时，需要被观察对象通过addObserver方法注册一个或多个观察者，在被观察对象的方法被调用时，
如果方法内有setChanged方法，就会改变changed属性为true，并调用notifyObservers方法调用观察者重写的update方法，
只有当为true时，才会调用update方法。

Observable类里除了注册方法addObserver，还有取消方法deleteObserver，如果不使用jdk改用手动实现，
也需要提供类似的方法来对观察者进行管理。方法内部逻辑不展开，只关注实现方式。

实际应用中，微信公众号就是被观察者，微信客户端就是观察者，当公众号上的文章发生变化时，客户端就会观察到这个变化并且通知给订阅的人，
但是客户端本身不需要关心变化的内容，只需要关心变化这一行为的发生。如果把通知方法直接写在公众号文章的修改方法后面，
就会造成业务逻辑的高度耦合，并且不利于修改。

### 扩展
书上通常定义为 观察者模式 = 出版者 + 订阅者，即观察者模式 = 发布订阅模式，实际上大部分时候也可以这样理解，
但是如果被特意问到了观察者模式和发布订阅模式的区别时，要知道它们的结构其实不太一样。

观察者模式中，对象（Subject）维持一系列依赖于它的对象（Observer），当有关状态发生变更时，Subject对象则通知一系列Observer对象进行更新，
Subject对象拥有添加、删除和通知一系列Observer的方法等，而Observer对象拥有更新方法等，
在Subject对象添加了一系列Observer对象之后，当有关状态发生变更时，Subject对象会通知这一系列Observer对象进行更新。

也就是，在观察者模式中，Subject和Observer是高度耦合的。

典型的场景为向报社订阅报纸，报社维持着一系列的用户，用户拥有者新增订阅和取消订阅的方法，只要报社更新了报纸，就会向订阅的用户们派送新的报纸，即传统定义上的一对多的关系。

发布订阅模式在中间加入了一个调度中心，由调度中心统一处理，可加入其他的处理逻辑，订阅者和发布者互不干扰，
如报社和订阅用户之间，加入了调度中心，报社有新报纸后只发到调度中心，订阅者向调度中心订阅报纸，同时调度中心会处理这些报纸，
比如优先派送老用户加急用户或较近的用户，这部分业务逻辑和对象已经没有关系不需要耦合，因此可以单独处理，
而用户也彻底和报社解耦，消除了依赖，用户只需要关心获取到的报纸，不需要关心报纸的来源和处理逻辑。